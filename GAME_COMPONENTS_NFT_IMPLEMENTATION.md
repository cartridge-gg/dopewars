# Game Components NFT Implementation

> **Documentation for the integration of game-components library into DopeWars**
>
> This document explains the architectural decisions, technical implementation, and rationale behind DopeWars' NFT integration using the game-components library.

## Table of Contents

- [Overview](#overview)
- [Goal](#goal)
- [The Core Challenge: Two Counter Problem](#the-core-challenge-two-counter-problem)
- [Existing DopeWars Architecture](#existing-dopewars-architecture)
- [The GameToken Model Solution](#the-gametoken-model-solution)
- [Architectural Decisions](#architectural-decisions)
  - [Decision 1: Soulbound vs Transferable NFTs](#decision-1-soulbound-vs-transferable-nfts)
  - [Decision 2: GameToken Model vs Architecture Refactor](#decision-2-gametoken-model-vs-architecture-refactor)
  - [Decision 3: Default Renderer vs Custom Renderer](#decision-3-default-renderer-vs-custom-renderer)
- [Comparison with Death Mountain](#comparison-with-death-mountain)
- [Implementation Details](#implementation-details)
- [Data Flow](#data-flow)
- [Testing and Verification](#testing-and-verification)
- [Future Considerations](#future-considerations)
- [References](#references)

---

## Overview

DopeWars has integrated the `game-components` library to enable players to view their game state as NFTs in their wallets. This integration creates ERC721 NFTs that display real-time game data (score, game-over status, player name) using the MinigameComponent pattern.

**Key Implementation Points:**
- âœ… NFTs are **soulbound** (non-transferable)
- âœ… Uses **GameToken model** to map NFT token_id to game state
- âœ… Employs **default renderer** for metadata generation
- âœ… Minimal changes to existing architecture

---

## Goal

**Primary Requirement:** Enable players to view their DopeWars game as an NFT in their wallet while playing.

**Success Criteria:**
1. When a player creates a game, an NFT is minted to their wallet
2. The NFT displays dynamic metadata (player name, score, game status)
3. The NFT updates as the game progresses
4. Implementation integrates cleanly with existing DopeWars architecture

---

## The Core Challenge: Two Counter Problem

DopeWars faces a critical architectural challenge: **two independent sequential counters** that cannot be assumed to stay synchronized.

### Counter 1: Game ID (Dojo UUID)

```cairo
// In src/systems/game.cairo:75
let game_id = world.dispatcher.uuid();
```

- Generated by Dojo's universal unique ID generator
- Increments: 1, 2, 3, 4, 5...
- Used as primary key in `Game` model

### Counter 2: NFT Token ID (ERC721 Counter)

```cairo
// Inside FullTokenContract (game-components library)
let token_id = self.token_counter.read() + 1;
self.token_counter.write(token_id);
```

- Generated by ERC721 contract's internal counter
- Increments: 1, 2, 3, 4, 5...
- Used as primary key for NFT ownership

### Why They Desynchronize

**Example Scenario:**

```
Step 1: Alice creates game
  â†’ game_id = 1 (from world.dispatcher.uuid())
  â†’ token_id = 1 (from ERC721 mint)
  âœ… Synchronized

Step 2: Bob creates game
  â†’ game_id = 2
  â†’ token_id = 2
  âœ… Still synchronized

Step 3: Charlie starts creating a game but transaction fails
  â†’ game_id = 3 (UUID already consumed)
  â†’ token_id = NOT INCREMENTED (mint never happened)
  âŒ Counters now out of sync

Step 4: Dave creates game
  â†’ game_id = 4
  â†’ token_id = 3 (uses next available)
  âŒ MISMATCH: game_id â‰  token_id
```

### Why This Matters

The game-components library needs to query game data by `token_id`:

```cairo
// In game_token_systems.cairo
fn score(self: @ContractState, token_id: u64) -> u32 {
    // We have token_id, but game data is keyed by (game_id, player_id)
    // How do we find the right game?

    // âŒ WRONG: Assume game_id == token_id
    let game = world.game(token_id, player_id); // Will fail when desynchronized!

    // âœ… CORRECT: Use GameToken mapping
    let game_token = world.read_model(token_id);
    let game = world.game(game_token.game_id, game_token.player_id);
}
```

**Without explicit mapping, we cannot reliably resolve token_id â†’ game_id.**

---

## Existing DopeWars Architecture

### Game Model Structure

```cairo
#[dojo::model]
pub struct Game {
    #[key]
    pub game_id: u32,              // From world.dispatcher.uuid()
    #[key]
    pub player_id: ContractAddress, // From get_caller_address()

    pub game_mode: GameMode,
    pub player_name: felt252,
    // ... other fields
}
```

**Key Characteristics:**
- **Composite keys:** (game_id, player_id)
- **game_id** is NOT globally unique per player
- **player_id** enforces ownership at the model level
- All queries require both game_id AND player_id

### System Function Signatures

```cairo
fn travel(game_id: u32, next_location: Locations, actions: Span<Actions>)
fn end_game(game_id: u32, actions: Span<Actions>)
```

- Functions accept `game_id` as parameter
- `player_id` derived from caller: `get_caller_address()`
- Ownership validated by composite key lookup

### Implications for NFT Integration

1. **Cannot use token_id as game key directly** (would require full refactor)
2. **Need mapping between token_id and (game_id, player_id)**
3. **Must maintain backward compatibility** with existing systems

---

## The GameToken Model Solution

We created an explicit mapping model to bridge the NFT world (token_id) and the game world (game_id, player_id).

### Model Definition

```cairo
// src/models/game_token.cairo
#[derive(Copy, Drop, Serde, Introspect)]
#[dojo::model]
pub struct GameToken {
    #[key]
    pub token_id: u64,              // NFT token ID (from ERC721)
    pub game_id: u32,               // DopeWars game ID (from UUID)
    pub player_id: ContractAddress, // Player address
}
```

### Why Each Field Exists

| Field | Purpose | Source |
|-------|---------|--------|
| `token_id` | Primary key for NFT queries | ERC721 counter in FullTokenContract |
| `game_id` | Links to Game model | `world.dispatcher.uuid()` |
| `player_id` | Links to Game model (composite key) | `get_caller_address()` |

### How It's Used

**When Creating a Game:**

```cairo
// src/systems/game.cairo:239-258
let game_id = world.dispatcher.uuid();
// ... create game ...

// Mint NFT
let nft_token_id = minigame_dispatcher.mint_game(...);

// Store the mapping
world.write_model(@GameToken {
    token_id: nft_token_id,
    game_id,
    player_id
});
```

**When Querying NFT Metadata:**

```cairo
// src/systems/game_token/contracts.cairo:84-104
fn score(self: @ContractState, token_id: u64) -> u32 {
    let world = self.world(@"dopewars");

    // Step 1: Get game mapping
    let game_token: GameToken = world.read_model(token_id);

    if game_token.game_id == 0 {
        return 0; // NFT exists but no game started
    }

    // Step 2: Load game using mapped IDs
    let mut store = StoreImpl::new(world);
    let mut game_store = GameStoreTrait::load(
        ref store,
        game_token.game_id,    // Mapped game_id
        game_token.player_id   // Mapped player_id
    );

    // Step 3: Return game data
    game_store.player.cash
}
```

### Example Mapping Table

| token_id | game_id | player_id |
|----------|---------|-----------|
| 1 | 1 | 0xAlice |
| 2 | 2 | 0xBob |
| 4 | 3 | 0xCharlie | â† Note the gap at token_id 3!
| 5 | 6 | 0xDave | â† game_id and token_id don't match

**This mapping allows reliable lookups regardless of counter synchronization.**

---

## Architectural Decisions

### Decision 1: Soulbound vs Transferable NFTs

**Chosen: Soulbound (Non-Transferable) âœ… for Phase 1**

#### All Options Considered

| Option | Description | Pros | Cons |
|--------|-------------|------|------|
| **A. Soulbound (Phase 1)** | NFT cannot be transferred | âœ… Matches existing architecture<br>âœ… NFT owner = game player always<br>âœ… Minimal code changes<br>âœ… No security concerns | âŒ Cannot trade games<br>âŒ NFT is just a trophy |
| **B. Transferable - Full Refactor** | NFT can be sold/traded<br>Game model uses token_id as key | âœ… Enables game marketplace<br>âœ… True NFT ownership<br>âœ… Clean single-key architecture<br>âœ… No GameToken model needed | âŒ Massive refactoring (50+ files)<br>âŒ 3-4 weeks development<br>âŒ High risk of bugs<br>âŒ Breaking change |
| **C. Hybrid - Both IDs (Phase 2.5)** | Functions accept both game_id AND token_id | âœ… Enables transferable NFTs<br>âœ… Minimal refactoring<br>âœ… Keeps existing architecture<br>âœ… 1-2 weeks development<br>âœ… Low-medium risk | âŒ More complex signatures<br>âŒ Frontend tracks both IDs<br>âŒ Slightly higher gas costs<br>âŒ player_id semantics shift |

#### Rationale for Soulbound

**1. Architectural Alignment**

DopeWars' Game model uses `player_id` (address) as a key:

```cairo
#[dojo::model]
pub struct Game {
    #[key]
    pub game_id: u32,
    #[key]
    pub player_id: ContractAddress, // Immutable key
}
```

If NFTs are transferable:
- Alice creates game â†’ player_id = Alice
- Alice transfers NFT to Bob
- Bob owns NFT but **cannot play** (player_id still = Alice)
- Alice can still play but **doesn't own NFT**

**This creates broken ownership invariant.**

**2. Minimal Implementation**

Only one parameter change required:

```cairo
minigame_dispatcher.mint_game(
    // ... parameters ...
    true  // soulbound = true (ONE LINE CHANGE)
);
```

vs. transferable NFTs requiring:
- Refactor Game model to use token_id as key
- Update all system functions
- Add ownership validation everywhere
- Rewrite 50+ files

**3. Meets Requirement**

Original goal: "view game NFT in wallet while playing"

Soulbound NFTs achieve this perfectly. Players see their game as an NFT with live-updating metadata without requiring game state to be transferable.

#### Implementation

```cairo
// src/systems/game.cairo:254
let nft_token_id = minigame_dispatcher.mint_game(
    Option::Some(player_name),
    Option::None, // settings_id
    Option::None, // start
    Option::None, // end
    Option::None, // objective_ids
    Option::None, // context
    Option::None, // client_url
    Option::None, // renderer_address
    player_id,    // to
    true          // soulbound - NFT cannot be transferred
);
```

#### Deep Dive: Option C - Hybrid Approach (Future Enhancement)

The hybrid approach enables transferable NFTs without massive refactoring by accepting both `game_id` and `token_id` as parameters.

**Key Insight:** `player_id` becomes a "storage namespace" rather than "current owner." NFT ownership determines access rights.

**Backend Example:**

```cairo
#[starknet::interface]
trait IGameActions<T> {
    fn travel(
        self: @T,
        game_id: u32,      // â† Keep existing
        token_id: u64,     // â† Add this
        next_location: Locations,
        actions: Span<Actions>
    );
}

fn travel(
    self: @ContractState,
    game_id: u32,
    token_id: u64,
    next_location: Locations,
    actions: Span<Actions>,
) {
    let world = self.world(@"dopewars");

    // Step 1: Validate caller owns the NFT
    let (token_address, _) = world.dns(@"game_token_systems").unwrap();
    assert_token_ownership(token_address, token_id);

    // Step 2: Validate token_id maps to game_id
    let game_token: GameToken = world.read_model(token_id);
    assert(game_token.game_id == game_id, 'token does not match game');

    // Step 3: Load game using ORIGINAL creator's player_id
    // (NOT get_caller_address()!)
    let mut store = StoreImpl::new(world);
    let mut game_store = GameStoreTrait::load(
        ref store,
        game_id,
        game_token.player_id  // â† From mapping (immutable)
    );

    // Step 4: Game logic proceeds normally
    // ...
}
```

**How NFT Transfers Work:**

```
Timeline:
1. Alice creates game
   â†’ Game { game_id: 5, player_id: 0xAlice }
   â†’ GameToken { token_id: 7, game_id: 5, player_id: 0xAlice }
   â†’ NFT #7 minted to Alice

2. Alice plays
   â†’ travel(game_id: 5, token_id: 7, ...)
   â†’ Ownership check: Alice owns NFT #7 âœ…
   â†’ Loads Game(5, 0xAlice) âœ…

3. Alice transfers NFT #7 to Bob
   â†’ No model updates needed!
   â†’ GameToken still: { token_id: 7, game_id: 5, player_id: 0xAlice }
   â†’ Game still: { game_id: 5, player_id: 0xAlice }

4. Bob plays the transferred game
   â†’ travel(game_id: 5, token_id: 7, ...)
   â†’ Ownership check: Bob owns NFT #7 âœ…
   â†’ GameToken maps to: Game(5, 0xAlice)
   â†’ Loads Game(5, 0xAlice) âœ…
   â†’ Bob can now play and modify the game!

5. Bob transfers to Charlie
   â†’ Charlie can play using Game(5, 0xAlice)
   â†’ Storage location never changes
```

**player_id Semantics Shift:**
- **Old meaning:** Current player/owner
- **New meaning:** Storage address for game data (immutable)
- **Ownership control:** Determined by NFT ownership (mutable)

**Frontend Token Discovery:**

```typescript
// 1. Query user's NFTs on wallet connect
const tokens = await getGameTokens(userAddress, GAME_TOKEN_CONTRACT);
// Returns: [7, 12, 15]

// 2. For each token, get game_id via GameToken mapping
const games = await Promise.all(
  tokens.map(async (tokenId) => {
    const gameToken = await world.readModel('GameToken', tokenId);
    return {
      tokenId,
      gameId: gameToken.game_id,
      storageOwner: gameToken.player_id,  // Original creator
      score: await gameTokenSystems.score(tokenId),
    };
  })
);

// 3. Display game selector
<GameSelector games={games} onSelect={(g) => selectGame(g.gameId, g.tokenId)} />

// 4. All calls use BOTH IDs
await travel(selectedGameId, selectedTokenId, nextLocation, actions);
```

**Implementation Requirements for Hybrid Approach:**

1. Change `soulbound: true` â†’ `soulbound: false` in mint_game()
2. Add `token_id: u64` parameter to all game action functions
3. Add ownership validation: `assert_token_ownership(token_address, token_id)`
4. Add mapping validation: `assert(game_token.game_id == game_id, 'mismatch')`
5. Use `game_token.player_id` instead of `get_caller_address()`
6. Frontend queries Torii's `token_balances` table to discover NFTs
7. Frontend tracks both game_id and token_id

**Effort Estimate:** 1-2 weeks, medium complexity

---

### Decision 2: GameToken Model vs Architecture Refactor

**Chosen: GameToken Model âœ…**

#### Options Considered

| Option | Description | Effort | Risk |
|--------|-------------|--------|------|
| **A. GameToken Model** | Add mapping model | Low (4 files) | Low |
| **B. Refactor to token_id keys** | Change Game model to use token_id | High (50+ files) | High |
| **C. Bidirectional mapping** | Two mapping models | Medium | Medium |

#### Why GameToken Model Wins

**1. Preserves Existing Architecture**

No changes needed to:
- Game model structure
- StoreImpl methods
- System function signatures
- Frontend query patterns
- Event definitions

**2. Clean Separation of Concerns**

```
NFT Layer (token_id)
         â†•
  GameToken Mapping â† NEW LAYER
         â†•
Game Layer (game_id, player_id)
```

The mapping acts as an adapter between two different identification systems.

**3. Minimal Code Changes**

Files created/modified:
- `src/models/game_token.cairo` (NEW - 20 lines)
- `src/systems/game_token/contracts.cairo` (modified - +10 lines)
- `src/systems/game.cairo` (modified - +15 lines)
- `src/lib.cairo` (modified - +2 lines)

Total: ~50 lines of code

vs. Architecture refactor: 1000+ lines changed across 50+ files

**4. Future Flexibility**

GameToken model can be extended without touching game logic:
- Add NFT metadata fields
- Track minting timestamps
- Support multiple NFT types
- Enable NFT marketplace queries

---

### Decision 3: Default Renderer vs Custom Renderer

**Chosen: Default Renderer âœ… (Phase 1)**

The game-components library provides a default SVG renderer. We deferred custom renderer implementation to focus on core functionality.

#### Rationale

**Phase 1 (Current):**
- Use default renderer from `game_components_utils`
- Provides basic NFT metadata and SVG visualization
- Meets MVP requirement for wallet display

**Phase 2 (Future):**
- Implement custom renderer with DopeWars branding
- Add rich game visuals (location, drugs, stats)
- Enhanced metadata for marketplaces

#### Implementation

```cairo
// src/systems/game_token/contracts.cairo:72
self.minigame.initializer(
    creator_address,
    "DopeWars",
    "Roll Your Own - Dope Wars on StarkNet. Build your empire in NYC.",
    "Dope Wars Team",
    "Dope Wars",
    "Strategy",
    "https://dopewars.gg/favicon.png",
    Option::None, // color - uses default
    Option::None, // client_url
    Option::None, // renderer_address - uses default renderer âœ…
    Option::None, // settings_address
    Option::None, // objectives_address
    token_address,
);
```

---

## Comparison with Death Mountain

Death Mountain is the reference implementation we studied. Here's how their approach differs:

### Death Mountain Architecture

```cairo
#[dojo::model]
pub struct AdventurerPacked {
    #[key]
    pub adventurer_id: u64,  // Single key = token_id
    pub packed: felt252,     // Packed game state
}

// Functions use token_id directly
fn start_game(adventurer_id: u64, weapon: u8)
fn explore(adventurer_id: u64, till_beast: bool)
```

**Key Points:**
- âœ… Single key architecture (token_id IS the game state key)
- âœ… No separate game_id counter
- âœ… Transferable NFTs (game ownership can be traded)
- âœ… Ownership validation via `assert_token_ownership()`

### DopeWars Architecture

```cairo
#[dojo::model]
pub struct Game {
    #[key]
    pub game_id: u32,        // From UUID counter
    #[key]
    pub player_id: ContractAddress, // Composite key
}

// Functions use game_id
fn travel(game_id: u32, next_location: Locations, ...)
fn end_game(game_id: u32, actions: Span<Actions>)
```

**Key Points:**
- âœ… Composite key architecture (game_id + player_id)
- âœ… Separate UUID counter for game_id
- âœ… Soulbound NFTs (non-transferable)
- âœ… GameToken mapping model bridges the gap

### Why Different Approaches?

| Aspect | Death Mountain | DopeWars | Reason |
|--------|---------------|----------|--------|
| **Primary Key** | token_id | (game_id, player_id) | DopeWars has existing composite key architecture |
| **NFT Transferability** | Transferable | Soulbound | DopeWars player_id is immutable key |
| **ID Generation** | ERC721 counter | Dojo UUID | DopeWars uses world.dispatcher.uuid() throughout |
| **Ownership Model** | NFT ownership = game access | Address-based access | DopeWars validates via composite key |
| **Mapping Model** | Not needed | GameToken required | Bridges two separate ID systems |

### Could We Copy Death Mountain's Approach?

**Yes, but it would require:**

1. **Rewrite Game model** to use token_id as single key
2. **Remove UUID generation** (world.dispatcher.uuid())
3. **Change all system functions** to accept token_id instead of game_id
4. **Add ownership validation** to every function
5. **Update frontend** to track token_id instead of game_id
6. **Migrate existing data** (if any)

**Estimated effort:** 2-3 weeks of development + high risk of bugs

**Our approach:** 1 day of development + low risk

---

## Implementation Details

### Files Created

1. **`src/models/game_token.cairo`**
   - Defines GameToken model
   - Provides GameTokenTrait with constructor

2. **`src/systems/game_token/contracts.cairo`**
   - Implements MinigameComponent integration
   - Provides IMinigameTokenData trait (score, game_over)
   - Initializes minigame metadata
   - Uses `core::num::traits::Zero` for player_id validation

### Files Modified

1. **`src/systems/game.cairo`**
   - Added NFT minting in `create_game()`
   - Stores GameToken mapping after minting
   - Imports IMinigameDispatcher

2. **`src/lib.cairo`**
   - Added game_token module export
   - Added game_token to models section

3. **`Scarb.toml`** (already done)
   - Added game-components dependencies
   - Added external contracts for building

### Key Functions

#### `score(token_id: u64) -> u32`

Returns the player's cash (score) for a given NFT.

```cairo
// src/systems/game_token/contracts.cairo:84
fn score(self: @ContractState, token_id: u64) -> u32 {
    let world = self.world(@"dopewars");
    let game_token: GameToken = world.read_model(token_id);

    if game_token.game_id == 0 {
        return 0; // No game mapped to this token
    }

    let mut store = StoreImpl::new(world);
    let mut game_store = GameStoreTrait::load(
        ref store, game_token.game_id, game_token.player_id
    );

    game_store.player.cash
}
```

#### `game_over(token_id: u64) -> bool`

Returns whether the game has ended for a given NFT.

```cairo
// src/systems/game_token/contracts.cairo:102
fn game_over(self: @ContractState, token_id: u64) -> bool {
    let world = self.world(@"dopewars");
    let game_token: GameToken = world.read_model(token_id);

    // Assert that the game exists (both game_id and player_id must be valid)
    assert(game_token.game_id != 0, 'game does not exist');
    assert(game_token.player_id.is_non_zero(), 'game does not exist');

    let store = StoreImpl::new(world);
    let game = store.game(game_token.game_id, game_token.player_id);
    game.game_over
}
```

**Note:** Unlike `score()` which returns `0` for non-existent games, `game_over()` asserts that the game exists. This is because:
- A score of `0` is a valid game state (player has no cash yet)
- A non-existent game shouldn't be queried for game-over status
- Assertions provide clearer error messages for invalid queries

---

## Data Flow

### Game Creation to NFT Minting

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. Player calls create_game(game_mode, player_name, ...)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2. Generate game_id = world.dispatcher.uuid()              â”‚
â”‚     game_id = 5                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3. Create Game model with (game_id=5, player_id=0xAlice)  â”‚
â”‚     store.set_game(@game)                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  4. Mint NFT via minigame_dispatcher.mint_game()            â”‚
â”‚     Returns token_id = 7 (from ERC721 counter)              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  5. Store GameToken mapping                                 â”‚
â”‚     world.write_model(@GameToken {                          â”‚
â”‚         token_id: 7,                                        â”‚
â”‚         game_id: 5,                                         â”‚
â”‚         player_id: 0xAlice                                  â”‚
â”‚     })                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  6. Emit GameCreated event                                  â”‚
â”‚     NFT appears in player's wallet                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### NFT Metadata Query Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  1. Wallet queries token_uri(token_id=7)                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  2. Default renderer calls game_token_systems.score(7)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  3. Read GameToken mapping                                  â”‚
â”‚     game_token = world.read_model(7)                        â”‚
â”‚     â†’ {token_id: 7, game_id: 5, player_id: 0xAlice}        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  4. Load game data using mapped IDs                         â”‚
â”‚     game_store = load(game_id=5, player_id=0xAlice)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  5. Return player.cash as score                             â”‚
â”‚     score = game_store.player.cash = $15,000                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  6. Renderer generates NFT metadata with score              â”‚
â”‚     Wallet displays: "DopeWars Game - Score: $15,000"       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Testing and Verification

### Build Verification

```bash
sozo build
```

Expected: Build completes with no errors (warnings are acceptable)

### Deployment Checklist

After deploying contracts:

1. **Verify game_token_systems is deployed**
   ```bash
   sozo model list
   # Should include GameToken model
   ```

2. **Create a test game**
   ```bash
   # Call create_game() and note the returned game_id
   ```

3. **Verify NFT was minted**
   ```bash
   # Query FullTokenContract for token ownership
   # Player's wallet should show new NFT
   ```

4. **Check GameToken mapping**
   ```bash
   # Query GameToken model with token_id
   # Should return correct game_id and player_id
   ```

5. **Verify metadata queries work**
   ```bash
   # Call game_token_systems.score(token_id)
   # Should return player's cash amount

   # Call game_token_systems.game_over(token_id)
   # Should return false for active game
   ```

### Expected NFT Behavior

**When viewing NFT in wallet:**
- âœ… NFT name includes player's chosen name
- âœ… NFT shows current score (cash amount)
- âœ… NFT indicates if game is over
- âœ… NFT displays DopeWars branding/description
- âœ… NFT metadata updates as game progresses

**When attempting to transfer NFT:**
- âŒ Transaction should fail (soulbound)
- âœ… Error message indicates non-transferability

---

## Future Considerations

### Phase 2: Custom Renderer

**Goal:** Replace default renderer with DopeWars-branded custom renderer

**Implementation:**
1. Create custom renderer contract implementing `IMinigameDetails`
2. Generate rich SVG with:
   - Player location visualization
   - Current drug inventory
   - Health/wanted status
   - Turn count and game mode
3. Deploy renderer contract
4. Update game_token_systems initializer to use custom renderer address

**Effort:** 1-2 weeks

### Phase 2.5: Hybrid Transferable NFTs (RECOMMENDED if trading desired)

**Goal:** Enable game trading as NFTs without massive refactoring

**Approach:** Add `token_id` parameter alongside existing `game_id` parameter

**Key Changes:**

1. **Update mint_game call:**
   ```cairo
   // Change from:
   true  // soulbound

   // To:
   false  // transferable
   ```

2. **Update function signatures:**
   ```cairo
   // Before:
   fn travel(game_id: u32, next_location: Locations, ...)
   fn end_game(game_id: u32, actions: Span<Actions>)

   // After:
   fn travel(game_id: u32, token_id: u64, next_location: Locations, ...)
   fn end_game(game_id: u32, token_id: u64, actions: Span<Actions>)
   ```

3. **Add validation logic:**
   ```cairo
   fn travel(game_id: u32, token_id: u64, ...) {
       // Validate NFT ownership
       assert_token_ownership(token_address, token_id);

       // Validate mapping
       let game_token = world.read_model(token_id);
       assert(game_token.game_id == game_id, 'mismatch');

       // Use mapped player_id (not caller!)
       let game_store = GameStoreTrait::load(
           ref store,
           game_id,
           game_token.player_id
       );
   }
   ```

4. **Frontend token discovery:**
   ```typescript
   // Query Torii for user's NFTs
   const getGameTokens = async (userAddress, tokenAddress) => {
       let url = `${TORII_SQL}/sql?query=
         SELECT token_id FROM token_balances
         WHERE account_address = "${userAddress}"
         AND contract_address = "${tokenAddress}"`;

       const response = await fetch(url);
       const data = await response.json();
       return data.map(t => parseInt(t.token_id.split(":")[1], 16));
   };

   // Display game selector
   const tokens = await getGameTokens(userAddress, GAME_TOKEN_CONTRACT);
   // tokens = [7, 12, 15]

   // User selects game
   await travel(gameId, selectedTokenId, nextLocation, actions);
   ```

**Benefits:**
- âœ… Enables NFT marketplace/trading
- âœ… Keeps existing Game model architecture
- âœ… player_id remains immutable (just changes meaning)
- âœ… No massive refactoring needed
- âœ… GameToken model stays useful

**Effort:** 1-2 weeks

**Risk:** Medium (requires careful validation logic, frontend changes)

### Phase 3: Full Architecture Refactor (NOT RECOMMENDED)

**Goal:** Enable game trading with single token_id key architecture (like Death Mountain)

**Why NOT Recommended:** Hybrid approach (Phase 2.5) achieves the same goal with 1/3 the effort and risk.

**What This Would Require:**

1. **Refactor Game Model**
   ```cairo
   // Change from:
   #[dojo::model]
   pub struct Game {
       #[key]
       pub game_id: u32,
       #[key]
       pub player_id: ContractAddress,
       // ...
   }

   // To:
   #[dojo::model]
   pub struct Game {
       #[key]
       pub token_id: u64,  // Single key
       pub player_id: ContractAddress,  // Regular field (mutable)
       // ...
   }
   ```

2. **Rewrite All System Functions**
   ```cairo
   // Before: 50+ function signatures like this
   fn travel(game_id: u32, next_location: Locations, ...)

   // After: All need to change to
   fn travel(token_id: u64, next_location: Locations, ...)
   ```

3. **Update All Queries**
   ```cairo
   // Before:
   let game = world.game(game_id, player_id);

   // After:
   let game = world.game(token_id);
   ```

4. **Rewrite StoreImpl and All Helpers**
   - All store methods expect (game_id, player_id)
   - Would need complete rewrite

5. **Add Transfer Hook**
   ```cairo
   fn on_nft_transfer(token_id: u64, from: Address, to: Address) {
       let mut game = world.read_model(token_id);
       game.player_id = to;
       world.write_model(@game);
   }
   ```

6. **Update Frontend**
   - All queries, events, state management
   - Rewrite game tracking logic

7. **Data Migration**
   - Migrate existing games to new model
   - Or start fresh (lose existing data)

**Files Impacted:** 50+ files across contracts and frontend

**Effort:** 3-4 weeks of development + 1-2 weeks testing

**Risk:** Very High
- Breaking changes everywhere
- High chance of introducing bugs
- Data migration complexity
- No backward compatibility

**Comparison:**

| Aspect | Phase 2.5 (Hybrid) | Phase 3 (Full Refactor) |
|--------|-------------------|------------------------|
| **Effort** | 1-2 weeks | 3-4 weeks |
| **Risk** | Medium | Very High |
| **Files Changed** | ~10 files | 50+ files |
| **Breaking Changes** | Minimal | Everything breaks |
| **Data Migration** | Not needed | Required |
| **GameToken Model** | Keep & use | Delete |
| **Transferable NFTs** | âœ… Yes | âœ… Yes |
| **Architecture** | Hybrid (both IDs) | Clean (single ID) |

**Verdict:** Only consider this if you want Death Mountain's exact architecture for philosophical reasons. The hybrid approach delivers the same functionality with significantly less risk and effort.

### Phase 4: Multiple NFT Collections

**Goal:** Different NFT types for different game modes

**Examples:**
- Ranked games â†’ Competitive Collection
- Casual games â†’ Fun Collection
- Special events â†’ Limited Edition Collection

**Implementation:**
- Deploy multiple FullTokenContract instances
- Update GameToken to include collection_address
- Route to appropriate collection based on game_mode

**Effort:** 1 week

---

## References

### Code Files

- `src/models/game_token.cairo` - GameToken model definition
- `src/systems/game_token/contracts.cairo` - MinigameComponent implementation
- `src/systems/game.cairo` - NFT minting integration
- `GAME_COMPONENTS_INTEGRATION_PLAN.md` - Original implementation plan

### External Documentation

- [game-components GitHub](https://github.com/cartridge-gg/game-components)
- [Death Mountain Reference](https://github.com/cartridge-gg/death-mountain)
- [Dojo Engine Documentation](https://book.dojoengine.org/)
- [ERC721 Standard](https://eips.ethereum.org/EIPS/eip-721)

### Related Decisions

- **Composite Keys:** DopeWars uses (game_id, player_id) for historical reasons
- **UUID Generation:** Dojo's world.dispatcher.uuid() is used throughout codebase
- **Soulbound Standard:** Following ERC5192 pattern for non-transferable tokens

---

## Summary

DopeWars' NFT integration prioritizes **pragmatic implementation** over architectural purity. We've documented three possible approaches for enabling game NFTs:

### Approach Comparison

| Feature | Phase 1: Soulbound | Phase 2.5: Hybrid | Phase 3: Full Refactor |
|---------|-------------------|-------------------|----------------------|
| **NFT Transferability** | âŒ Non-transferable | âœ… Transferable | âœ… Transferable |
| **Game Model** | `(game_id, player_id)` | `(game_id, player_id)` | `(token_id)` |
| **Function Signatures** | `fn(game_id, ...)` | `fn(game_id, token_id, ...)` | `fn(token_id, ...)` |
| **GameToken Model** | âœ… Required | âœ… Required | âŒ Not needed |
| **player_id Meaning** | Current owner | Storage namespace | Mutable field |
| **Development Effort** | 1 day | 1-2 weeks | 3-4 weeks |
| **Risk Level** | Very Low | Medium | Very High |
| **Files Changed** | 4 files | ~10 files | 50+ files |
| **Breaking Changes** | None | Minimal | Everything |
| **Backward Compatible** | âœ… Yes | âœ… Mostly | âŒ No |
| **Status** | âœ… **Implemented** | ğŸ“‹ Documented | âš ï¸ Not Recommended |

### Current Implementation: Phase 1 (Soulbound)

The GameToken model adds a minimal mapping layer that:

1. âœ… Preserves existing codebase architecture
2. âœ… Solves the two-counter synchronization problem
3. âœ… Enables reliable NFT metadata queries
4. âœ… Maintains clean separation of concerns
5. âœ… Provides foundation for future enhancements (Phase 2.5)

**The key insight:** Rather than forcing DopeWars to conform to Death Mountain's architecture, we created an adapter (GameToken) that bridges the gap between DopeWars' composite-key design and the game-components' token-id-based expectations.

This decision trades a small amount of storage overhead (one mapping model) for massive reduction in refactoring risk and development time.

### Recommended Path Forward

1. âœ… **Phase 1 (Complete):** Launch with soulbound NFTs
   - Players can view games as NFTs in wallets
   - Zero risk, immediate value

2. ğŸ¯ **Phase 2 (Next):** Deploy and gather user feedback
   - Monitor wallet integration
   - Assess demand for NFT trading

3. ğŸ”„ **Phase 2.5 (If trading desired):** Implement hybrid approach
   - Add token_id parameter to functions
   - Enable NFT marketplace without massive refactor
   - 1-2 weeks development, medium risk

4. â­ï¸ **Phase 3 (Unlikely needed):** Only if architectural purity is priority
   - Full refactor to token_id-based architecture
   - Same functionality as Phase 2.5 with 3x the effort

**Recommendation:** Start with Phase 1 (soulbound), evaluate market demand, then implement Phase 2.5 (hybrid) if NFT trading is desired. Avoid Phase 3 unless there's a compelling reason beyond just "matching Death Mountain's architecture."

---

*Last Updated: 2025-10-05*
*Author: DopeWars Development Team*
*Contributors: Sequential thinking analysis of hybrid architecture approach*
