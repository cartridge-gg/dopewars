# Game Components NFT Implementation

> **Documentation for the integration of game-components library into DopeWars**
>
> This document explains the architectural decisions, technical implementation, and rationale behind DopeWars' NFT integration using the game-components library.

## Table of Contents

- [Overview](#overview)
- [Goal](#goal)
- [The Core Challenge: Two Counter Problem](#the-core-challenge-two-counter-problem)
- [Existing DopeWars Architecture](#existing-dopewars-architecture)
- [The GameToken Model Solution](#the-gametoken-model-solution)
- [Architectural Decisions](#architectural-decisions)
  - [Decision 1: Soulbound vs Transferable NFTs](#decision-1-soulbound-vs-transferable-nfts)
  - [Decision 2: GameToken Model vs Architecture Refactor](#decision-2-gametoken-model-vs-architecture-refactor)
  - [Decision 3: Default Renderer vs Custom Renderer](#decision-3-default-renderer-vs-custom-renderer)
- [Comparison with Death Mountain](#comparison-with-death-mountain)
- [Implementation Details](#implementation-details)
- [Data Flow](#data-flow)
- [Testing and Verification](#testing-and-verification)
- [Future Considerations](#future-considerations)
- [References](#references)

---

## Overview

DopeWars has integrated the `game-components` library to enable players to view their game state as custom game NFTs in their wallets, as well as transfer those tokens between players (essentially transferring ownership and enabling the new owner to pick up where the original owner left off, for example). This integration creates ERC721 NFTs that display real-time game data (score, game-over status, player name) using the MinigameComponent pattern.

**Key Implementation Points:**
- NFTs are transferable
- Uses GameToken model to map NFT token_id to game state
- Token ownership validation on all game actions
- Token lifecycle management via pre_action/post_action
- Employs default renderer for metadata generation (TODO: custom renderer with a more polished interface could be implemented)
- Minimal changes to existing architecture

---

## Goal

**Primary Requirement:** Enable players to view their DopeWars game as an NFT in their wallet while playing.

**Success Criteria:**
1. When a player creates a game, an NFT is minted to their wallet
2. The NFT displays dynamic metadata (player name, score, game status)
3. The NFT updates as the game progresses
4. Implementation integrates cleanly with existing DopeWars architecture

---

## The Core Challenge: Two Counter Problem

DopeWars faces a critical architectural challenge: **two independent sequential counters** that cannot be assumed to stay synchronized.

### Counter 1: Game ID (Dojo UUID)

```cairo
// In src/systems/game.cairo:75
let game_id = world.dispatcher.uuid();
```

- Generated by Dojo's universal unique ID generator
- Increments: 1, 2, 3, 4, 5...
- Used as primary key in `Game` model

### Counter 2: NFT Token ID (ERC721 Counter)

```cairo
// Inside FullTokenContract (game-components library)
let token_id = self.token_counter.read() + 1;
self.token_counter.write(token_id);
```

- Generated by ERC721 contract's internal counter
- Increments: 1, 2, 3, 4, 5...
- Used as primary key for NFT ownership


### Why This Matters

The game-components library needs to query game data by `token_id`:

```cairo
// In game_token_systems.cairo
fn score(self: @ContractState, token_id: u64) -> u32 {
    // We have token_id, but game data is keyed by (game_id, player_id)
    // How do we find the right game?

    // ❌ WRONG: Assume game_id == token_id
    let game = world.game(token_id, player_id); // Will fail when desynchronized!

    // ✅ CORRECT: Use GameToken mapping
    let game_token = world.read_model(token_id);
    let game = world.game(game_token.game_id, game_token.player_id);
}
```

**Without explicit mapping, we cannot reliably resolve token_id → game_id.**

---

## Existing DopeWars Architecture

### Game Model Structure

```cairo
#[dojo::model]
pub struct Game {
    #[key]
    pub game_id: u32,              // From world.dispatcher.uuid()
    #[key]
    pub player_id: ContractAddress, // From get_caller_address()

    pub game_mode: GameMode,
    pub player_name: felt252,
    // ... other fields
}
```

**Key Characteristics:**
- **Composite keys:** (game_id, player_id)
- **game_id** is NOT globally unique per player
- **player_id** enforces ownership at the model level
- All queries require both game_id AND player_id

### System Function Signatures

```cairo
fn travel(game_id: u32, next_location: Locations, actions: Span<Actions>)
fn end_game(game_id: u32, actions: Span<Actions>)
```

- Functions accept `game_id` as parameter
- `player_id` derived from caller: `get_caller_address()`
- Ownership validated by composite key lookup

### Implications for NFT Integration

1. **Cannot use token_id as game key directly** (would require full refactor)
2. **Need mapping between token_id and (game_id, player_id)**
3. **Must maintain backward compatibility** with existing systems

---

## The GameToken Model Solution

We created an explicit mapping model to bridge the NFT world (token_id) and the game world (game_id, player_id).

### Model Definition

```cairo
// src/models/game_token.cairo
#[derive(Copy, Drop, Serde, Introspect)]
#[dojo::model]
pub struct GameToken {
    #[key]
    pub token_id: u64,              // NFT token ID (from ERC721)
    pub game_id: u32,               // DopeWars game ID (from UUID)
    pub player_id: ContractAddress, // Player address
}
```

### Why Each Field Exists

| Field | Purpose | Source |
|-------|---------|--------|
| `token_id` | Primary key for NFT queries | ERC721 counter in FullTokenContract |
| `game_id` | Links to Game model | `world.dispatcher.uuid()` |
| `player_id` | Links to Game model (composite key) | `get_caller_address()` |

### How It's Used

**When Creating a Game:**

Game creation is a two-step process:
1. The player first mints a "blank" game NFT, which gives them a `minigame_token_id`.
2. The player then calls `create_game`, passing in the `minigame_token_id` to initialize the game state.

```cairo
// Inside create_game() in src/systems/game.cairo

// 1. Ownership of the pre-minted token_id is verified
let token_address = self._get_game_token_address();
assert_token_ownership(token_address, minigame_token_id);

// 2. A new, internal game_id is generated
let game_id = world.dispatcher.uuid();

// 3. The Game model is created...
// ...

// 4. The crucial mapping is stored to link the two IDs
world.write_model(@GameToken {
    token_id: minigame_token_id,
    game_id,
    player_id
});
```

**When Querying NFT Metadata:**

```cairo
// src/systems/game_token/contracts.cairo:84-104
fn score(self: @ContractState, token_id: u64) -> u32 {
    let world = self.world(@"dopewars");

    // Step 1: Get game mapping
    let game_token: GameToken = world.read_model(token_id);

    if game_token.game_id == 0 {
        return 0; // NFT exists but no game started
    }

    // Step 2: Load game using mapped IDs
    let mut store = StoreImpl::new(world);
    let mut game_store = GameStoreTrait::load(
        ref store,
        game_token.game_id,    // Mapped game_id
        game_token.player_id   // Mapped player_id
    );

    // Step 3: Return game data
    game_store.player.cash
}
```

### Example Mapping Table

| token_id | game_id | player_id |
|----------|---------|-----------|
| 1 | 1 | 0xAlice |
| 2 | 2 | 0xBob |
| 4 | 3 | 0xCharlie | ← Note the gap at token_id 3!
| 5 | 6 | 0xDave | ← game_id and token_id don't match

**This mapping allows reliable lookups regardless of counter synchronization.**

---

## Architectural Decisions

### Decision 1: Transferable NFTs via Hybrid Approach

**Chosen: Transferable NFTs ✅**

The primary goal was to allow players to trade their in-game progress as NFTs on marketplaces. This required making the game state NFTs transferable.

However, the existing DopeWars architecture is built around a composite key `(game_id, player_id)` for all game state models. A full refactor to a single `token_id` key was deemed unsafe.

Instead, a **hybrid approach** was implemented. This approach keeps the existing data models but uses the NFT's `token_id` as the primary identifier for all game actions. It provides the full benefits of transferable NFTs with minimal architectural changes.

**Key Principles of the Hybrid Approach:**

1.  **`token_id` as the Public Key:** All game system functions (`travel`, `end_game`, `decide`, etc.) accept a `token_id: u64` as their primary parameter. The frontend and other clients only need to track the `token_id`.

2.  **`GameToken` for Mapping:** The `GameToken` model serves as a crucial mapping layer, linking the public-facing `token_id` to the internal `(game_id, player_id)` composite key used for storing game state.

3.  **NFT Ownership as Authorization:** Before any action is performed, the system validates that the `get_caller_address()` is the current owner of the `token_id` being used. This is done via the `assert_token_ownership` helper from the `game-components` library.

4.  **`player_id` as a "Storage Namespace":** The `player_id` in the `Game` model no longer represents the *current* owner. Instead, it's an immutable pointer to the original creator's address, acting as a stable storage location for that game's data. Ownership is now dictated solely by who holds the NFT.

**Implementation Example (`travel` function):**

This pattern is repeated across all game systems:

```cairo
fn travel(
    self: @ContractState,
    token_id: u64, // ← Only token_id is needed
    next_location: Locations,
    actions: Span<Actions>,
) {
    // 1. Get the game's token contract address
    let token_address = self._get_game_token_address();

    // 2. Validate that the caller owns the NFT for this token_id
    assert_token_ownership(token_address, token_id);

    // 3. Check token lifecycle (e.g., game is not over)
    pre_action(token_address, token_id);

    // 4. Load the game state using the GameToken mapping
    let mut store = StoreImpl::new(self.world(@"dopewars"));
    let game = store.game_by_token_id(token_id); // ← Automatic lookup via GameToken

    // 5. Load the game store using the *original* creator's player_id
    let mut game_store = GameStoreImpl::load(
        ref store,
        game.game_id,      // from GameToken mapping
        game.player_id     // from GameToken mapping (immutable storage key)
    );

    // 6. Execute game logic
    // ...

    // 7. Sync token state after the action
    post_action(token_address, token_id);
}
```

**Benefits:**
- Enables a full NFT marketplace for games.
- Avoided a large, high-risk refactoring of the entire codebase.
- The API is clean, with functions taking a single `token_id`.
- Security is maintained by checking NFT ownership for every action.


### Decision 2: GameToken Model vs Architecture Refactor

**Chosen: GameToken Model**

#### Options Considered

| Option | Description | Effort | Risk |
|--------|-------------|--------|------|
| **A. GameToken Model** | Add mapping model | Low | Low |
| **B. Refactor to token_id keys** | Change Game model to use token_id | High | High |
| **C. Bidirectional mapping** | Two mapping models | Medium | Medium |

#### Why GameToken Model Wins

**1. Preserves Existing Architecture**

No changes needed to:
- Game model structure
- StoreImpl methods
- System function signatures
- Frontend query patterns
- Event definitions

**2. Clean Separation of Concerns**

```
NFT Layer (token_id)
         ↕
  GameToken Mapping ← NEW LAYER
         ↕
Game Layer (game_id, player_id)
```

The mapping acts as an adapter between two different identification systems.

**3. Minimal Code Changes**

Files created/modified:
- `src/models/game_token.cairo` (created)
- `src/systems/game_token/contracts.cairo` (modified)
- `src/systems/game.cairo` (modified)
- `src/lib.cairo` (modified)


vs. Architecture refactor: 1000+ lines changed across 50+ files

**4. Future Flexibility**

GameToken model can be extended without touching game logic:
- Add NFT metadata fields
- Track minting timestamps
- Support multiple NFT types
- Enable NFT marketplace queries

---

### Decision 3: Default Renderer

**Chosen: Default Renderer**

For the initial implementation, the default SVG renderer provided by the `game-components` library is used. This provides basic NFT metadata and visualization that meets the core requirement for wallet display.

A custom renderer, along with custom settings and objectives contracts, are planned for future development.

#### Implementation

The `initializer` function call shows the integration points for these future components.

```cairo
// src/systems/game_token/contracts.cairo:72
self.minigame.initializer(
    creator_address,
    "DopeWars",
    "Roll Your Own - Dope Wars on StarkNet. Build your empire.",
    "Dope DAO/ Cartridge",
    "Dope Wars",
    "Strategy",
    "https://dopewars.gg/favicon.png",
    Option::Some("#11ED83"), // color
    Option::None, // client_url
    Option::None, // renderer_address - TODO: Implement custom renderer
    Option::None, // settings_address - TODO: Implement custom settings
    Option::None, // objectives_address - TODO: Implement custom objectives
    token_address,
);
```

---

## Comparison with Death Mountain

Death Mountain is the reference implementation we studied. Here's how their approach differs:

### Death Mountain Architecture

```cairo
#[dojo::model]
pub struct AdventurerPacked {
    #[key]
    pub adventurer_id: u64,  // Single key = token_id
    pub packed: felt252,     // Packed game state
}

// Functions use token_id directly
fn start_game(adventurer_id: u64, weapon: u8)
fn explore(adventurer_id: u64, till_beast: bool)
```

**Key Points:**
- Single key architecture (token_id IS the game state key)
- No separate game_id counter
- Transferable NFTs (game ownership can be traded)
- Ownership validation via `assert_token_ownership()`

### DopeWars Architecture

```cairo
#[dojo::model]
pub struct Game {
    #[key]
    pub game_id: u32,        // From UUID counter
    #[key]
    pub player_id: ContractAddress, // Composite key
}

// Functions use game_id
fn travel(game_id: u32, next_location: Locations, ...)
fn end_game(game_id: u32, actions: Span<Actions>)
```

**Key Points:**
- Composite key architecture (game_id + player_id)
- Separate UUID counter for game_id
- Transferable NFTs (via hybrid approach)
- GameToken mapping model bridges the gap

### Why Different Approaches?

| Aspect | Death Mountain | DopeWars | Reason |
|--------|---------------|----------|--------|
| **Primary Key** | token_id | (game_id, player_id) | DopeWars has existing composite key architecture |
| **NFT Transferability** | Transferable | Transferable (Hybrid) | DopeWars uses a hybrid model where NFT ownership grants access, while the game state's `player_id` key remains an immutable storage pointer. |
| **ID Generation** | ERC721 counter | Dojo UUID | DopeWars uses world.dispatcher.uuid() throughout |
| **Ownership Model** | NFT ownership = game access | Address-based access | DopeWars validates via composite key |
| **Mapping Model** | Not needed | GameToken required | Bridges two separate ID systems |

### Could We Copy Death Mountain's Approach?

**Yes, but it would require:**

1. **Rewrite Game model** to use token_id as single key
2. **Remove UUID generation** (world.dispatcher.uuid())
3. **Migrate existing data** (if any)

---

## Implementation Details

### Files Created

1. **`src/models/game_token.cairo`**
   - Defines GameToken model
   - Provides GameTokenTrait with constructor

2. **`src/systems/game_token/contracts.cairo`**
   - Implements MinigameComponent integration
   - Provides IMinigameTokenData trait (score, game_over)
   - Initializes minigame metadata
   - Uses `core::num::traits::Zero` for player_id validation

### Files Modified

1. **`src/systems/game.cairo`**
   - Added NFT minting in `create_game()`
   - Stores GameToken mapping after minting
   - Imports IMinigameDispatcher

2. **`src/lib.cairo`**
   - Added game_token module export
   - Added game_token to models section

3. **`Scarb.toml`** (already done)
   - Added game-components dependencies
   - Added external contracts for building

### Key Functions

#### `score(token_id: u64) -> u32`

Returns the player's cash (score) for a given NFT.

```cairo
// src/systems/game_token/contracts.cairo:84
fn score(self: @ContractState, token_id: u64) -> u32 {
    let world = self.world(@"dopewars");
    let game_token: GameToken = world.read_model(token_id);

    if game_token.game_id == 0 {
        return 0; // No game mapped to this token
    }

    let mut store = StoreImpl::new(world);
    let mut game_store = GameStoreTrait::load(
        ref store, game_token.game_id, game_token.player_id
    );

    game_store.player.cash
}
```

#### `game_over(token_id: u64) -> bool`

Returns whether the game has ended for a given NFT.

```cairo
// src/systems/game_token/contracts.cairo:102
fn game_over(self: @ContractState, token_id: u64) -> bool {
    let world = self.world(@"dopewars");
    let game_token: GameToken = world.read_model(token_id);

    // Assert that the game exists (both game_id and player_id must be valid)
    assert(game_token.game_id != 0, 'game does not exist');
    assert(game_token.player_id.is_non_zero(), 'game does not exist');

    let store = StoreImpl::new(world);
    let game = store.game(game_token.game_id, game_token.player_id);
    game.game_over
}
```

**Note:** Unlike `score()` which returns `0` for non-existent games, `game_over()` asserts that the game exists. This is because:
- A score of `0` is a valid game state (player has no cash yet)
- A non-existent game shouldn't be queried for game-over status
- Assertions provide clearer error messages for invalid queries

---

## Data Flow

### Game Creation to NFT Minting

```
            (Step 1: Pre-computation on Client)
┌─────────────────────────────────────────────────────────────┐
│  1. Player calls a 'mint' function on the NFT contract     │
│     to get a `minigame_token_id` (e.g., token_id = 7).        │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│  2. Player calls create_game(..., minigame_token_id: 7)    │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│  3. Ownership of token_id 7 is verified via                 │
│     `assert_token_ownership`.                               │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│  4. Generate internal game_id = world.dispatcher.uuid()     │
│     (e.g., game_id = 5)                                     │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│  5. Create Game model with (game_id=5, player_id=0xAlice)  │
│     store.set_game(@game)                                   │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│  6. Store GameToken mapping to link the two IDs             │
│     world.write_model(@GameToken {                          │
│         token_id: 7,                                        │
│         game_id: 5,                                         │
│         player_id: 0xAlice                                  │
│     })                                                      │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│  7. Emit GameCreated event                                  │
│     The previously minted NFT is now linked to an active game.│
└─────────────────────────────────────────────────────────────┘
```

### NFT Metadata Query Flow

```
┌─────────────────────────────────────────────────────────────┐
│  1. Wallet queries token_uri(token_id=7)                    │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│  2. Default renderer calls game_token_systems.score(7)      │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│  3. Read GameToken mapping                                  │
│     game_token = world.read_model(7)                        │
│     → {token_id: 7, game_id: 5, player_id: 0xAlice}        │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│  4. Load game data using mapped IDs                         │
│     game_store = load(game_id=5, player_id=0xAlice)        │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│  5. Return player.cash as score                             │
│     score = game_store.player.cash = $15,000                │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│  6. Renderer generates NFT metadata with score              │
│     Wallet displays: "DopeWars Game - Score: $15,000"       │
└─────────────────────────────────────────────────────────────┘
```

---

## Testing and Verification

### Build Verification

```bash
sozo build
```

Expected: Build completes with no errors (warnings are acceptable)

### Deployment Checklist

After deploying contracts:

1. **Verify game_token_systems is deployed**
   ```bash
   sozo model list
   # Should include GameToken model
   ```

2. **Create a test game**
   ```bash
   # Call create_game() and note the returned game_id
   ```

3. **Verify NFT was minted**
   ```bash
   # Query FullTokenContract for token ownership
   # Player's wallet should show new NFT
   ```

4. **Check GameToken mapping**
   ```bash
   # Query GameToken model with token_id
   # Should return correct game_id and player_id
   ```

5. **Verify metadata queries work**
   ```bash
   # Call game_token_systems.score(token_id)
   # Should return player's cash amount

   # Call game_token_systems.game_over(token_id)
   # Should return false for active game
   ```

### Expected NFT Behavior

**When viewing NFT in wallet:**
- NFT name includes player's chosen name
- NFT shows current score (cash amount)
- NFT indicates if game is over
- NFT displays DopeWars branding/description
- NFT metadata updates as game progresses

**When attempting to transfer NFT:**
- Transaction should succeed.
- The new owner should be able to play the game.
- The original owner should lose access to game actions.

---

## Future Considerations

### Custom Renderer, Settings, and Objectives

Further enhancements are planned by implementing custom components from the `game-components` library.

**Custom Renderer (TODO):**
- **Goal:** Replace the default renderer with a DopeWars-branded, visually rich SVG.
- **Implementation:**
  1. Create a contract that implements the `IMinigameDetails` trait.
  2. Generate an SVG that includes dynamic game data like player location, drug inventory, health, wanted status, etc.
  3. Deploy the renderer and update the `initializer` to point to its address.

**Custom Settings & Objectives (TODO):**
- **Goal:** Define specific game configurations or win/loss conditions that can be displayed on the NFT.
- **Implementation:**
  1. Create contracts that implement the `ISettings` and `IObjectives` traits.
  2. These can be used to define different game modes (e.g., "Ranked," "Casual") or specific goals (e.g., "Reach $1M cash").
  3. Deploy the contracts and link them in the `initializer`.

### Full Architecture Refactor

**Goal:** Enable game trading with single token_id key architecture (like Death Mountain)

**What This Would Require:**

1. **Refactor Game Model**
   ```cairo
   // Change from:
   #[dojo::model]
   pub struct Game {
       #[key]
       pub game_id: u32,
       #[key]
       pub player_id: ContractAddress,
       // ...
   }

   // To:
   #[dojo::model]
   pub struct Game {
       #[key]
       pub token_id: u64,  // Single key
       pub player_id: ContractAddress,  // Regular field (mutable)
       // ...
   }
   ```

2. **Rewrite All System Functions**
   ```cairo
   // Before: 50+ function signatures like this
   fn travel(game_id: u32, next_location: Locations, ...)

   // After: All need to change to
   fn travel(token_id: u64, next_location: Locations, ...)
   ```

3. **Update All Queries**
   ```cairo
   // Before:
   let game = world.game(game_id, player_id);

   // After:
   let game = world.game(token_id);
   ```

4. **Rewrite StoreImpl and All Helpers**
   - All store methods expect (game_id, player_id)
   - Would need complete rewrite

5. **Add Transfer Hook**
   ```cairo
   fn on_nft_transfer(token_id: u64, from: Address, to: Address) {
       let mut game = world.read_model(token_id);
       game.player_id = to;
       world.write_model(@game);
   }
   ```

6. **Update Frontend**
   - All queries, events, state management
   - Rewrite game tracking logic

7. **Data Migration**
   - Migrate existing games to new model
   - Or start fresh (lose existing data)


**Comparison:**

| Aspect | Phase 2.5 (Hybrid) | Phase 3 (Full Refactor) |
|--------|-------------------|------------------------|
| **Effort** | 1-2 weeks | 3-4 weeks |
| **Risk** | Medium | Very High |
| **Files Changed** | ~10 files | 50+ files |
| **Breaking Changes** | Minimal | Everything breaks |
| **Data Migration** | Not needed | Required |
| **GameToken Model** | Keep & use | Delete |
| **Transferable NFTs** | Yes | Yes |
| **Architecture** | Hybrid (both IDs) | Clean (single ID) |


---

## References

### Code Files

- `src/models/game_token.cairo` - GameToken model definition
- `src/systems/game_token/contracts.cairo` - MinigameComponent implementation
- `src/systems/game.cairo` - NFT minting integration

### External Documentation

- [game-components GitHub](https://github.com/cartridge-gg/game-components)
- [Death Mountain Reference](https://github.com/cartridge-gg/death-mountain)
- [Dojo Engine Documentation](https://book.dojoengine.org/)
- [ERC721 Standard](https://eips.ethereum.org/EIPS/eip-721)

### Related Decisions

- **Composite Keys:** DopeWars uses (game_id, player_id) for historical reasons
- **UUID Generation:** Dojo's world.dispatcher.uuid() is used throughout codebase

---

## Summary

DopeWars' NFT integration uses a **pragmatic hybrid approach** to enable fully transferable, marketplace-ready game NFTs while preserving the existing, stable core architecture.

Instead of a high-risk refactor, the implementation uses a `GameToken` model as an adapter. This model maps the public-facing `token_id` of an NFT to the game's internal `(game_id, player_id)` key, solving the two-counter synchronization problem and allowing for a clean, `token_id`-based API for all game actions.

**The key principles of the current architecture are:**

1.  **Transferable NFTs:** Games can be freely traded.
2.  **`token_id` as the Key:** All game actions are initiated via the NFT's `token_id`.
3.  **Ownership as Authorization:** Game access is secured by verifying NFT ownership for every action.
4.  **Stable Architecture:** The core `Game` model and its composite keys remain unchanged, minimizing risk.
5.  **`player_id` as a Namespace:** The `player_id` field now serves as an immutable storage pointer, not a representation of the current owner.

This approach delivers the full functionality of tradable game NFTs.

---
